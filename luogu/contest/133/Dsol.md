题意：

有一张 $n$ 个点和 $m$ 条边构成的**有向**图，每个点有一把钥匙 $k_i$。你能进入一个点当且仅当你有对应点的钥匙。
保证 $k_i$ 是排列。
现在你拿到了 $i$ 号点的钥匙并到了 $i$ 号点。你需要对每个 $i$ 求出你最多能到几个点。

$n\le 1.5\times 10^6, m\le 3\times 10^6$

---

枚举从哪个点开始，下一个能走到的新点是固定的。我们考虑抽出 $i \to k_i$ 的每个环分别计算答案。



## 暴力的做法

考虑一个暴力做法。

我们枚举一个起点，计算它的答案。

从起点开始，贪心向外拓展。拓展到点 $i$ 时，检查是否有到 $i+1$ 的边，如果存在，就考虑 $i+1$ 的每条回溯边，将一个后缀合并，接下来拓展点 $i+1$。

（一个可能的拓展流程。）

![](https://cdn.luogu.com.cn/upload/image_hosting/vjazdavx.png)

为了方便后面的叙述，我们定义一个**强连通分量**，它表示得到这个分量起点对应的钥匙，并从这个点开始行走，可以经过分量中的每个点而回到开头。

那么上面的暴力可以描述为：

1. 首先，将起点作为一个单独的强连通分量插入栈。
2. 我们来拓展最后一个强连通分量，记 $x$ 表示下一个应该被拓展的点。如果最后一个强连通分量存在边能到达 $x$，我们就进入第三步。否则就退出这个过程。
3. 找到最前的，$x$ 存在边能到达的强连通分量，然后将一个强连通分量的后缀合并为同一个强连通分量。（如上图的第四步。）

总复杂度 $O(n^2)$，可以得到 $70$ 分。



## 更加优秀的做法

我们考虑如果求得了 $x$ 的答案，是否能快速计算 $x-1$ 的答案。显然如果 $x$ 能走到 $y$，那么所有能抵达 $x$ 的点也能走到 $y$。尝试均摊，下面我们进行一些定义：

定义一个**强联通结构**是由若干个**强连通分量**组成的序列，其中从某个**强连通分量**出发，可以到达这个及这个以后的每个**强连通分量**内部的点。也就是说，上面的暴力其实在维护一个强连通结构。

于是，我们可以类似的维护若干个**强连通结构**来帮助我们计算答案。

（下图中，我们将模拟，已求出 $2\dots 6$ 的答案，现在求 $1$ 号点的答案的过程。）

![](https://cdn.luogu.com.cn/upload/image_hosting/zz8aagx4.png)

令 $pre_i$ 表示所有有到点 $i$ 的边的点中，编号最大的点。

如果我们要计算一个新点 $x$ 的答案，做以下几步：

1. 新建一个**强连通结构**，内部仅包含一个**强连通分量**即它自己，然后进入第二步。
2. 我们来检查是否需要合并最前的两个**强连通结构**。（此时，第一个强连通结构一定只包含一个**强连通分量**。）令 $y$ 为下一个**强连通结构**的开头，只需考虑 $pre_y$ 和 $x$ 的大小关系即可。如果成功合并则进入第三步，否则退出这个流程。
3. 我们来合并最前面的**强连通结构**的一些**强连通分量**。我们枚举这个**强连通结构**最前的第一个强连通分量的每个入边，然后将一个前缀合并（如上图的第三步。）此时，如果这个**强连通结构**内部只有一个**强连通分量**了，就说明可能和下一个**强连通结构**合并了，返回第二步操作。否则退出这个流程。

上面的操作，朴素实现的复杂度为 $O(nm)$。如果使用启发式合并等方法维护，总复杂度可能为 $O(n\log n)$。

事实上，适当使用桶来记录返祖边，即可简单完成维护。

我们来分析时间复杂度，注意到只需要执行 $O(n)$ 次插入桶和查询桶最大值的操作，由于查找桶的编号需要使用并查集，因此总复杂度 $O(n\alpha(n))$。