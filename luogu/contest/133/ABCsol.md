## T1

如果修改 $a_i$，最优的修改方案要么是令 $a_i = a_{i+1}-1$，要么是令 $a_i = a_{i-1}+1$。

那么就可以得到一个简单的 $O(n^2)$ 做法，即枚举修改的位置，并计算答案。

预处理出未进行修改时，每个元素作为连续上升子序列的开头与结尾时的最长长度，记为 $f_i,g_i$。

如果存在 $x$ 满足 $a_{i+1}-1\ge x \ge a_{i-1}+1$，那么可以进行合适的修改使得构造出长度为 $g_{i-1}+1+f_{i+1}$ 的答案。

否则只能得到 $g_{i-1}+1$ 或 $f_{i+1}-1$。扫一遍判断即可。复杂度 $O(n)$。

## T2

注意到只有 $a>b>c$ 时，$(a,b,c)$ 的贡献才不为 $0$。

**解法一：**

根据调和级数，我们有：
$$
\sum_{i=1}^n \dfrac{n}{i} = O(n\log n)
$$

枚举 $b$ 和 $c$，再枚举 $s$ 表示 $a$ 是 $c$ 的几倍，这样满足条件的 $a$ 是一段区间，记为 $[L,R]$，于是我们需要计算：
$$
\sum_{b=1}^n \sum_{c=b+1}^n \lfloor\dfrac{b}{c}\rfloor \sum_{s=1}^{n/c} s \sum_{a=L}^R \lfloor\dfrac{a}{b}\rfloor
$$
对每个 $b$，使用前缀和预处理出 $\sum \lfloor\dfrac{i}{b}\rfloor$ ，即可消去最后一个求和符号。

如果暴力枚举 $b,c,s$，总复杂度为 $O(n^2\log n)$，可以通过此题。

**解法二**

我们有：
$$
\sum_{i\geqslant 1}\frac{1}{i^2}=\frac{\pi^2}{6}
$$
枚举 $a$，枚举 $b,c$ 分别是 $a$ 的几倍，我们需要求 $b\in[L_b,R_b],c\in[L_c,R_c]$ 的所有 $b,c$ 对的 $\lfloor\frac{b}{c}\rfloor$ 之和，我们可以预处理一个二维前缀和统计，于是时间复杂度为：
$$
\sum_{i=1}^n(\frac ni)^2\leqslant n^2\sum_{i\geqslant 1}\frac{1}{i^2}=O(n^2)
$$

## T3 

首先注意到，我们不能删去 $B$ 中出现的任意数字，我们不妨称这些数是关键的数。

而且，删掉不关键的数一定不会使得某个已经匹配的位置无法匹配上，因此我们可以先删去所有不关键的数（称删完的序列为 $C$），找到所有有可能匹配上的位置，可以使用 KMP 算法。

接下来我们枚举每个 $B$ 在 $C$ 中出现的位置，这一定是 $C$ 中一个长度为 $m$ 的区间。可以发现，每个方案的出现次数和之和，等于每个区间可以匹配上的方案数之和。

假设这段区间对应到 $A$ 中是区间 $[l,r]$，那么我们需要把 $[l,r]$ 中所有不关键的数删去，若区间 $[l,r]$ 中有 $t$ 个不关键的数，不关键的数总数为 $T$，那么方案数是 ${T-t\choose d-t}$，意义是我们强制选择这 $t$ 个数，其余的数我们还要选择 $d-t$ 个。

那么我们就要统计所有这样的区间中不关键的数数量，由于这些区间左右端点递增，可以使用尺取法计算。

时间复杂度：$O(n)$。
