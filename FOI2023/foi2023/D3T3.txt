从N个中任取M个呢？？？？


#include<iostream>
#include<memory.h>
using namespace std;
int n,h[105],dp[4002][4002];
int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&h[i]);
	}
	memset(dp, 0, sizeof(dp));
	dp[0][0]=1;
	for(int i=0;i<n;i++){
		for(int j=2000-h[i];j>=0;j--){
			for(int k=2000-h[i];k>=0;k--){
				if(dp[j][k])dp[j+h[i]][k]=dp[j][k];
				if(dp[j][k])dp[j][k+h[i]]=dp[j][k];
			}
		}
	}
	for(int i=2000;i>0;i--){
		if(dp[i][i]){
			cout<<i;
			return 0;
		}
	}
	cout<<"Impossible";
}

#include<bits/stdc++.h>
using namespace std;
int n,h[105],f[105][2005],sum=0;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>h[i]; sum+=h[i];
	}
	memset(f,-11451419,sizeof(f));
	f[0][0]=0;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=sum;j++) {
			f[i][j]=max(f[i-1][j],f[i-1][j+h[i]]);
			if(j>=h[i]) f[i][j]=max(f[i][j],f[i-1][j-h[i]]+h[i]);
			else f[i][j]=max(f[i][j],f[i-1][h[i]-j]+j);
		}
	if(f[n][0]>0) cout<<f[n][0];
	else cout<<"Impossible";
	return 0;
}



#include<bits/stdc++.h>
using namespace std;
int n,h[105],dp[105][2005],sum;
signed main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
		sum+=h[i];
	}
	memset(dp,128,sizeof(dp));
	dp[0][0]=0;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=sum;j++){
			dp[i][j]=max(dp[i-1][j],dp[i-1][j+h[i]]);
			if(j>=h[i]) dp[i][j]=max(dp[i][j],dp[i-1][j-h[i]]+h[i]);
			else    dp[i][j]=max(dp[i][j],dp[i-1][h[i]-j]+j);
		}
	if(dp[n][0]==0)   cout<<"Impossible";
	else	cout<<dp[n][0];
	return 0;
}


#include <bits/stdc++.h>

using namespace std;

int main() {
  int n;
  scanf("%d", &n);
  int h[n + 1], sum = 0;
  for (int i = 1; i <= n; ++i) {
    scanf("%d", &h[i]);
    sum += h[i];
  }

  int dp[n + 1][sum + 1];
  memset(dp, 128, sizeof(dp));
  dp[0][0] = 0;
  sum >>= 1;
  for (int i = 1; i <= n; ++i) {
    for (int j = 0; j <= sum; ++j) {
      dp[i][j] = dp[i - 1][j];

      if (j >= h[i]) {
        dp[i][j] = max(dp[i][j], dp[i - 1][j - h[i]]);
      }

      if (j + h[i] <= sum) {
        dp[i][j] = max(dp[i][j], dp[i - 1][j + h[i]] + h[i]);
      } else if (h[i] >= j) {
        dp[i][j] = max(dp[i][j], dp[i - 1][h[i] - j] + (h[i] - j));
      }
    }
  }

  if (dp[n][0] > 0) {
    cout << dp[n][0] << endl;
  } else {
    cout << "Impossible" << endl;
  }
}


#include <bits/stdc++.h>

using namespace std;

int main() {
  int n;
  scanf("%d", &n);
  int h[n + 1], sum = 0;
  for (int i = 1; i <= n; ++i) {
    scanf("%d", &h[i]);
    sum += h[i];
  }

  int dp[n + 1][sum + 1];
  memset(dp, 128, sizeof(dp));
  dp[0][0] = 0;
  sum >>= 1;
  for (int i = 1; i <= n; ++i) {
    for (int j = 0; j <= sum; ++j) {
      dp[i][j] = max(dp[i - 1][j], dp[i - 1][j + h[i]]);
      if (j >= h[i]) {
        dp[i][j] = max(dp[i][j], dp[i - 1][j - h[i]] + h[i]);
      } else {
        dp[i][j] = max(dp[i][j], dp[i - 1][h[i] - j] + j);
      }
    }
  }

  if (dp[n][0] > 0) {
    cout << dp[n][0] << endl;
  } else {
    cout << "Impossible" << endl;
  }
}



 年 月 日，一场突发的灾难将纽约世界贸易中心大厦夷为平地， 曾亲眼目睹了这次灾难。为了纪念 “” 事件， 决定自己用水晶来搭建一座双塔。
 有  块水晶，每块水晶有一个高度，他想用这 N 块水晶搭建两座有同样高度的塔，使他们成为一座双塔， 可以从这  块水晶中任取 
（
）
块来搭建。但是他不知道能否使两座塔有同样的高度，也不知道如果能搭建成一座双塔，这座双塔的最大高度是多少。所以他来请你帮忙。
给定水晶的数量 
（
）
和每块水晶的高度 （ 块水晶高度的总和不超过 ），你的任务是判断 能否用这些水晶搭建成一座双塔（两座塔有同样的高度），如果能，则输出所能搭建的双塔的最大高度，否则输出 。

输入格式
输入第一行为一个数 ，表示水晶的数量。
第二行为  个数，第  个数表示第  个水晶的高度 。

输出格式
输出仅包含一行，如果能搭成一座双塔，则输出双塔的最大高度，否则输出一个字符串 。

样例
样例输入

5
1 3 4 5 2
样例输出

7